# 11. 组件

## 11.1 什么是组件？

组件 (Component) 是 Vue.js 最强大的功能之一。
组件可以扩展 HTML 元素，封装可重用的代码。
在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。
在有些情况下，组件也可以表现为用 is 特性进行了扩展的原生 HTML 元素。

所有的 Vue 组件同时也都是 Vue 的实例，
所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。

## 11.2 使用组件

### 11.2.1 全局注册

我们已经知道，可以通过以下方式创建一个 Vue 实例：

    new Vue({
        el: '#some-element',
        // 选项
    })

要注册一个全局组件，可以使用 `Vue.component(tagName, options)`。
例如：

    Vue.component('my-component', {
        // 选项
    })

请注意，对于自定义标签的命名 Vue.js 不强制遵循 [W3C 规则](https://www.w3.org/TR/custom-elements/#concepts) (小写，并且包含一个短杠)，
尽管这被认为是最佳实践。

组件在注册之后，
便可以作为自定义元素 `<my-component></my-component>` 在一个实例的模板中使用。
注意确保在初始化根实例之前注册组件：

查看：[./examples/ch11/1.registration.global.html](./examples/ch11/1.registration.global.html)

    <div id="example">
        <my-component></my-component>
    </div>
    <script>
        // 注册
        Vue.component('my-component', {
            template: '<div>A custom component!</div>'
        })

        // 创建根实例
        new Vue({
            el: '#example'
        })
    </script>

渲染为：

    <div id="example">
        <div>A custom component!</div>
    </div>

### 11.2.2 局部注册

你不必把每个组件都注册到全局。
你可以通过某个 Vue 实例/组件的实例选项 `components` 注册仅在其作用域中可用的组件：

查看：[./examples/ch11/1.registration.local.html](./examples/ch11/1.registration.local.html)

    <div id="example">
        <my-component></my-component>
    </div>
    <script>
        new Vue({
            el: "#example",
            components: {
                // <my-component> 将只在父组件模板中可用
                'my-component': {
                    template: '<div>A custom component?</div>'
                }
            }
        })
    </script>

这种封装也适用于其它可注册的 Vue 功能，比如指令。

### 11.2.3 DOM 模板解析注意事项

当使用 DOM 作为模板时 (例如，使用 `el` 选项来把 Vue 实例挂载到一个已有内容的元素上)，
你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。
尤其要注意，像 `<ul>`、`<ol>`、`<table>`、`<select>` 这样的元素里允许包含的元素有限制，
而另一些像 `<option>` 这样的元素只能出现在某些特定元素的内部。

在自定义组件中使用这些受限制的元素时会导致一些问题，例如：

    <table>
        <my-row>...</my-row>
    </table>

自定义组件 `<my-row>` 会被当作无效的内容，因此会导致错误的渲染结果。
变通的方案是使用特殊的 `is` 特性：

    <table>
        <tr is="my-row"></tr>
    </table>

**应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制**：

 * `<script type="text/x-template">`
 * JavaScript 内联模板字符串
 * `.vue` 组件

因此，请尽可能使用字符串模板。

### 11.2.4 data 必须是函数

查看：[./examples/ch11/3.data.html](./examples/ch11/3.data.html)

构造 Vue 实例时传入的各种选项大多数都可以在组件里使用。
只有一个例外：data 必须是函数。实际上，如果你这么做：

    Vue.component('my-component', {
        template: '<span>{{ message }}</span>',
        data: {
            message: 'hello'
        }
    })

那么 Vue 会停止运行，并在控制台发出警告，告诉你在组件实例中 `data` 必须是一个函数。
但理解这种规则为何存在也是很有益处的，所以让我们先作个弊：

    <div id="example-2">
        <simple-counter></simple-counter>
        <simple-counter></simple-counter>
        <simple-counter></simple-counter>
    </div>
    <script>
        var data = { counter: 0 }

        Vue.component('simple-counter', {
            template: '<button v-on:click="counter += 1">{{ counter }}</button>',
            // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
            // 但是我们却给每个组件实例返回了同一个对象的引用
            data: function () {
                return data
            }
        })

        new Vue({
            el: '#example-2'
        })
    </script>

由于这三个组件实例共享了同一个 `data` 对象，
因此递增一个 counter 会影响所有组件！这就错了。
我们可以通过为每个组件返回全新的数据对象来修复这个问题：

    <div id="example-3">
            <simple-counter></simple-counter>
            <simple-counter></simple-counter>
            <simple-counter></simple-counter>
    </div>
    <script>
        Vue.component('simple-counter', {
            template: '<button v-on:click="counter += 1">{{ counter }}</button>',
            // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
            // 但是我们却给每个组件实例返回了同一个对象的引用
            data: function () {
                return {
                    counter: 0
                }
            }
        })

        new Vue({
            el: '#example-3'
        })
    </script>

现在每个 counter 都有它自己内部的状态了

### 11.2.5 组件组合

组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：
组件 A 在它的模板中使用了组件 B。
它们之间必然需要相互通信：
父组件可能要给子组件下发数据，子组件则可能要将它内部发生的事情告知父组件。
然而，通过一个良好定义的接口来尽可能将父子组件解耦也是很重要的。
这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。

在 Vue 中，父子组件的关系可以总结为 **prop 向下传递，事件向上传递**。
父组件通过 **prop** 给子组件下发数据，
子组件通过**事件**给父组件发送消息。
看看它们是怎么工作的。

![组件组合](./images/11.1.props-events.png)

## 11.3 Prop

### 11.3.1 使用 Prop 传递数据

组件实例的作用域是**孤立**的。
这意味着不能 (也不应该) 在子组件的模板内直接引用父组件的数据。
父组件的数据需要通过 **prop** 才能下发到子组件中。

子组件要显式地用 `props` [选项](https://cn.vuejs.org/v2/api/#props)声明它预期的数据：

查看：[./examples/ch11/4.prop.html](./examples/ch11/4.prop.html)

    Vue.component('child', {
        // 声明 props
        props: ['message'],
        // 就像 data 一样，prop 也可以在模板中使用
        // 同样也可以在 vm 实例中通过 this.message 来使用
        template: '<span>{{ message }}</span>'
    })

然后我们可以这样向它传入一个普通字符串：

    <child message="hello!"></child>
    <child message="world!"></child>


### 11.3.2 camelCase VS kebab-case

HTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，
camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：

    Vue.component('child', {
        // 在 JavaScript 中使用 camelCase
        props: ['myMessage'],
        template: '<span>{{ myMessage }}</span>'
    })

    <!-- 在 HTML 中使用 kebab-case -->
    <child my-message="hello!"></child>

如果你使用字符串模板，则没有这些限制。

### 11.3.3 动态 prop

与绑定到任何普通的 HTML 特性相类似，
我们可以用 `v-bind` 来动态地将 prop 绑定到父组件的数据。
每当父组件的数据变化时，该变化也会传导给子组件：

查看：[./examples/ch11/5.prop.dynamic.html](./examples/ch11/5.prop.dynamic.html)

    <div id="example">
        <input v-model="parentMsg">
        <br>
        <child v-bind:my-message="parentMsg"></child>
    </div>
    <script>
        Vue.component('child', {
            // 声明 props
            props: ['myMessage'],
            template: '<span>{{ myMessage }}</span>'
        })

        new Vue( { 
            el: "#example",
            data: {
                "parentMsg": ""
            }
        } );
    </script>


如果你想把一个对象的所有属性作为 prop 进行传递，
可以使用不带任何参数的 `v-bind` (即用 `v-bind` 而不是 `v-bind:prop-name`)。
例如，已知一个 `todo` 对象：

    todo: {
        text: 'Learn Vue',
        isComplete: false
    }

然后：

    <todo-item v-bind="todo"></todo-item>

将等价于：

    <todo-item
        v-bind:text="todo.text"
        v-bind:is-complete="todo.isComplete"
    ></todo-item>


示例：

    <div id="example2">
        <todo-item v-bind:items="todo"></todo-item>
    </div>
    <script>
        Vue.component('todo-item', {
            // 声明 props
            props: ['items'],
            template: 
            '<ul>' 
            +   '<li v-for="item in items"' 
            +      ' v-if="!item.isComplete">{{ item.text }}</li>'
            + '</ul>'
        })

        new Vue( { 
            el: "#example2",
            data: {
                todo: [
                    { text: 'Learn Vue', isComplete: false },
                    { text: 'Learn Java', isComplete: true },
                    { text: 'Learn JS', isComplete: false },
                ]
            }
        } );
    </script>

### 11.3.4 字面量语法 VS 动态语法

初学者常犯的一个错误是使用字面量语法传递数值：

    <!-- 传递了一个字符串 "1" -->
    <comp some-prop="1"></comp>

因为它是一个字面量 prop，它的值是字符串 `"1"` 而不是一个数值。
如果想传递一个真正的 JavaScript 数值，则需要使用 `v-bind`，
从而让它的值被当作 JavaScript 表达式计算：

    <!-- 传递真正的数值 -->
    <comp v-bind:some-prop="1"></comp>

### 11.3.5 单向数据流

Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会。
这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。

另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。
这意味着你不应该在子组件内部改变 prop。
如果你这么做了，Vue 会在控制台给出警告。

在两种情况下，我们很容易忍不住想去修改 prop 中数据：

 1）Prop 作为初始值传入后，子组件想把它当作局部数据来用；

 2）Prop 作为原始数据传入，由子组件处理成其它数据输出。

对这两种情况，正确的应对方式是：

 1）定义一个局部变量，并用 prop 的值初始化它：

    props: ['initialCounter'],
        data: function () {
        return { counter: this.initialCounter }
    }

 2）定义一个计算属性，处理 prop 的值并返回：

    props: ['size'],
        computed: {
        normalizedSize: function () {
            return this.size.trim().toLowerCase()
        }
    }

注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，
如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。

### 11.3.6 Prop 验证

我们可以为组件的 prop 指定验证规则。
如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。

要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组：

    Vue.component('example', {
        props: {
            // 基础类型检测 (`null` 指允许任何类型)
            propA: Number,
            // 可能是多种类型
            propB: [String, Number],
            // 必传且是字符串
            propC: {
                type: String,
                required: true
            },
            // 数值且有默认值
            propD: {
                type: Number,
                default: 100
            },
            // 数组/对象的默认值应当由一个工厂函数返回
            propE: {
                type: Object,
                default: function () {
                    return { message: 'hello' }
                }
            },
            // 自定义验证函数
            propF: {
                validator: function (value) {
                    return value > 10
                }
            }
        }
    })

`type` 可以是下面原生构造器：
 * String
 * Number
 * Boolean
 * Function
 * Object
 * Array
 * Symbol

`type` 也可以是一个自定义构造器函数，使用 `instanceof` 检测。

当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。
注意 prop 会在组件实例创建**之前**进行校验，
所以在 `default` 或 `validator` 函数里，
诸如 `data`、`computed` 或 `methods` 等实例属性还无法使用。

## 11.4 非 Prop 特性

所谓非 prop 特性，就是指它可以直接传入组件，而不需要定义相应的 prop。

尽管为组件定义明确的 prop 是推荐的传参方式，组件的作者却并不总能预见到组件被使用的场景。
所以，组件可以接收任意传入的特性，这些特性都会被添加到组件的根元素上。

例如，假设我们使用了第三方组件 `bs-date-input`，它包含一个 Bootstrap 插件，
该插件需要在 `input` 上添加 `data-3d-date-picker` 这个特性。
这时可以把特性直接添加到组件上 (不需要事先定义 prop)：

    <bs-date-input data-3d-date-picker="true"></bs-date-input>

添加属性 `data-3d-date-picker="true"` 之后，
它会被自动添加到 `bs-date-input` 的根元素上。

### 11.4.1 替换/合并现有的特性

假设这是 `bs-date-input` 的模板：

    <input type="date" class="form-control">

为了给该日期选择器插件增加一个特殊的主题，我们可能需要增加一个特殊的 class，比如：

    <bs-date-input
        data-3d-date-picker="true"
        class="date-picker-theme-dark"
    ></bs-date-input>

在这个例子当中，我们定义了两个不同的 `class` 值：
 * `form-control`，来自组件自身的模板
 * `date-picker-theme-dark`，来自父组件

对于多数特性来说，传递给组件的值会覆盖组件本身设定的值。
即例如传递 `type="large"` 将会覆盖 `type="date"` 且有可能破坏该组件！
所幸我们对待 `class` 和 `style` 特性会更聪明一些，
这两个特性的值都会做合并 (merge) 操作，
让最终生成的值为：`form-control date-picker-theme-dark`。

## 11.5 自定义事件

我们知道，父组件使用 prop 传递数据给子组件。但子组件怎么跟父组件通信呢？
这个时候 Vue 的自定义事件系统就派得上用场了。

### 11.5.1 使用 v-on 绑定自定义事件

每个 Vue 实例都实现了[事件接口](https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6)，
即：
 * 使用 `$on(eventName)` 监听事件
 * 使用 `$emit(eventName)` 触发事件

Vue 的事件系统与浏览器的 [EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) 有所不同。
尽管它们的运行起来类似，但是 `$on` 和 `$emit` 并不是`addEventListener` 和 `dispatchEvent` 的别名。

另外，父组件可以在使用子组件的地方直接用 `v-on` 来监听子组件触发的事件。

不能用 `$on` 监听子组件释放的事件，而必须在模板里直接用 `v-on` 绑定，参见下面的例子。

查看：[./examples/ch11/6.event.html](./examples/ch11/6.event.html)

    <div id="counter-event-example">
        <p>{{ total }}</p>
        <button-counter v-on:increment="incrementTotal"></button-counter>
        <button-counter v-on:increment="incrementTotal"></button-counter>
    </div>
    <script>
        Vue.component('button-counter', {
            template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
            data: function () {
                return {
                    counter: 0
                }
            },
            methods: {
                incrementCounter: function () {
                    this.counter += 1
                    this.$emit('increment')
                }
            }
        })

        new Vue({
            el: '#counter-event-example',
            data: {
                total: 0
            },
            methods: {
                incrementTotal: function () {
                    this.total += 1
                }
            }
        })
    </script>

在本例中，子组件已经和它外部完全解耦了。
它所做的只是报告自己的内部事件，因为父组件可能会关心这些事件。请注意这一点很重要。

### 11.5.2 给组件绑定原生事件

有时候，你可能想在某个组件的根元素上监听一个原生事件。
可以使用 `v-on` 的修饰符 `.native`。例如：

    <my-component v-on:click.native="doTheThing"></my-component>

### 11.5.3 .sync 修饰符

在一些情况下，我们可能会需要对一个 prop 进行“双向绑定”。
事实上，这正是 Vue 1.x 中的 `.sync` 修饰符所提供的功能。
当一个子组件改变了一个带 `.sync` 的 prop 的值时，这个变化也会同步到父组件中所绑定的值。
这很方便，但也会导致问题，因为它破坏了单向数据流。
由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，
当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。
这在 debug 复杂结构的应用时会带来很高的维护成本。

上面所说的正是我们在 2.0 中移除 `.sync` 的理由。
但是在 2.0 发布之后的实际应用中，我们发现 `.sync` 还是有其适用之处，
比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。

从 2.3.0 起我们重新引入了 `.sync` 修饰符，但是这次它只是作为一个编译时的语法糖存在。
它会被扩展为一个自动更新父组件属性的 `v-on` 监听器。

如下代码

    <comp :foo.sync="bar"></comp>

会被扩展为：

    <comp :foo="bar" @update:foo="val => bar = val"></comp>

当子组件需要更新 `foo` 的值时，它需要显式地触发一个更新事件：

    this.$emit('update:foo', newValue)

### 11.5.4 使用自定义事件的表单输入组件

自定义事件可以用来创建自定义的表单输入组件，使用 `v-model` 来进行数据双向绑定。要牢记：

    <input v-model="something">

这不过是以下示例的语法糖：

    <input
        v-bind:value="something"
        v-on:input="something = $event.target.value">
    
所以在组件中使用时，它相当于下面的简写：

    <custom-input
        v-bind:value="something"
        v-on:input="something = arguments[0]">
    </custom-input>

所以要让组件的 `v-model` 生效，它应该 (从 2.2.0 起是可配置的)：
 * 接受一个 `value prop`
 * 在有新的值时触发 `input` 事件并将新值作为参数

我们来看一个非常简单的货币输入的自定义控件：

查看：[./examples/ch11/7.input.html](./examples/ch11/7.input.html)

    <div id="example">
        <currency-input v-model="price"></currency-input>
    </div>
    <script>
        Vue.component('currency-input', {
            template: '\
                <span>\
                $\
                <input\
                    ref="input"\
                    v-bind:value="value"\
                    v-on:input="updateValue($event.target.value)"\
                >\
                </span>\
            ',
            props: ['value'],
            methods: {
                // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制
                updateValue: function (value) {
                    var formattedValue = value
                        // 删除两侧的空格符
                        .trim()
                        // 保留 2 位小数
                        .slice(
                        0,
                        value.indexOf('.') === -1
                            ? value.length
                            : value.indexOf('.') + 3
                        )
                    // 如果值尚不合规，则手动覆盖为合规的值
                    if (formattedValue !== value) {
                        this.$refs.input.value = formattedValue
                    }
                    // 通过 input 事件带出数值
                    this.$emit('input', Number(formattedValue))
                }
            }
        })

        new Vue({
            el: '#example',
            data: {
                price: 0
            }
        })
    </script>


### 11.5.5 自定义组件的 v-model

默认情况下，一个组件的 `v-model` 会使用 `value` prop 和 `input` 事件。
但是诸如单选框、复选框之类的输入类型可能把 `value` 用作了别的目的。
`model` 选项可以避免这样的冲突：

    Vue.component('my-checkbox', {
        model: {
            prop: 'checked',
            event: 'change'
        },
        props: {
            checked: Boolean,
            // 这样就允许拿 `value` 这个 prop 做其它事了
            value: String
        },
        // ...
    })

    <my-checkbox v-model="foo" value="some value"></my-checkbox>

上述代码等价于：

    <my-checkbox
        :checked="foo"
        @change="val => { foo = val }"
        value="some value">
    </my-checkbox>

注意你仍然需要显式声明 `checked` 这个 prop。

### 11.5.6 非父子组件的通信

有时候，非父子关系的两个组件之间也需要通信。
在简单的场景下，可以使用一个空的 Vue 实例作为事件总线：

    var bus = new Vue()

    // 触发组件 A 中的事件
    bus.$emit('id-selected', 1)

    // 在组件 B 创建的钩子中监听事件
    bus.$on('id-selected', function (id) {
        // ...
    })

在复杂的情况下，我们应该考虑使用专门的[状态管理模式](https://cn.vuejs.org/v2/guide/state-management.html)。