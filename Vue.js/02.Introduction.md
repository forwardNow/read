- [2. 介绍](#2-%E4%BB%8B%E7%BB%8D)
    - [2.1 Vue.js 是什么](#21-vuejs-%E6%98%AF%E4%BB%80%E4%B9%88)
    - [2.2 起步](#22-%E8%B5%B7%E6%AD%A5)
    - [2.3 声明式渲染](#23-%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%B8%B2%E6%9F%93)
    - [2.4 条件与循环](#24-%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF)
    - [2.5 处理用户输入](#25-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5)
    - [2.6 组件化应用构建](#26-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA)
    - [2.7 与自定义元素的关系](#27-%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%B3%E7%B3%BB)
    
# 2. 介绍

## 2.1 Vue.js 是什么

Vue (读音 /vju:/，类似于 view) 是一套用于构建用户界面的渐进式框架。

## 2.2 起步

[./examples/ch02/1.Hello world.html](./examples/ch02/1.Hello%20world.html)

## 2.3 声明式渲染

Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：

    <div id="app">
        {{ message }}
    </div>

    var app = new Vue({
        el: '#app',
        data: {
            message: 'Hello Vue!'
        }
    })

我们已经成功创建了第一个 Vue 应用！
看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。
现在数据和 DOM 已经被建立了关联，所有东西都是**响应式**的。

我们要怎么确认呢？
打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，
并修改 `app.message` 的值，你将看到上例相应地更新。

除了文本插值，我们还可以像这样来绑定元素特性：

查看：[./examples/ch02/2.v-bind.html](./examples/ch02/2.v-bind.html)

    <div id="app-2">
        <span v-bind:title="message">
            鼠标悬停几秒钟查看此处动态绑定的提示信息！
        </span>
    </div>

    var app2 = new Vue({
        el: '#app-2',
        data: {
            message: '页面加载于 ' + new Date().toLocaleString()
        }
    })

这里我们遇到了一点新东西。你看到的 `v-bind` 特性被称为**指令**。
指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊特性。
可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。
在这里，该指令的意思是：“将这个元素节点的 `title` 特性和 Vue 实例的 `message` 属性保持一致”。

如果你再次打开浏览器的 JavaScript 控制台，输入 `app2.message = '新消息'`，
就会再一次看到这个绑定了 `title` 特性的 HTML 已经进行了更新。


## 2.4 条件与循环

控制切换一个元素是否显示也相当简单：

查看：[./examples/ch02/3.if.html](./examples/ch02/3.if.html)

    <div id="app-3">
        <p v-if="seen">现在你看到我了</p>
    </div>

    var app3 = new Vue({
        el: '#app-3',
        data: {
            seen: true
        }
    })

继续在控制台输入 `app3.seen = false`，你会发现之前显示的消息消失了。

这个例子演示了我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM 结构。

此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用[过渡效果](https://cn.vuejs.org/v2/guide/transitions.html)。

还有其它很多指令，每个都有特殊的功能。例如，`v-for` 指令可以绑定数组的数据来渲染一个项目列表：

查看：[./examples/ch02/4.for.html](./examples/ch02/4.for.html)

    <div id="app-4">
        <ol>
            <li v-for="todo in todos">
                {{ todo.text }}
            </li>
        </ol>
    </div>

    var app4 = new Vue({
        el: '#app-4',
        data: {
            todos: [
                { text: '学习 JavaScript' },
                { text: '学习 Vue' },
                { text: '整个牛项目' }
            ]
        }
    })

在控制台里，输入 `app4.todos.push({ text: '新项目' })`，你会发现列表最后添加了一个新项目。

## 2.5 处理用户输入

为了让用户和你的应用进行交互，我们可以用 `v-on` 指令添加一个事件监听器，
通过它调用在 Vue 实例中定义的方法：

查看：[./examples/ch02/5.v-on.html](./examples/ch02/5.v-on.html)

    <div id="app-5">
        <p>{{ message }}</p>
        <button v-on:click="reverseMessage">逆转消息</button>
    </div>

    var app5 = new Vue({
        el: '#app-5',
        data: {
            message: 'Hello Vue.js!'
        },
        methods: {
            reverseMessage: function () {
                this.message = this.message.split('').reverse().join('')
            }
        }
    })

注意在 `reverseMessage` 方法中，我们更新了应用的状态，
但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。



Vue 还提供了 `v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定。

查看：[./examples/ch02/6.v-model.html](./examples/ch02/6.v-model.html)

    <div id="app-6">
        <p>{{ message }}</p>
        <input v-model="message">
    </div>

    var app6 = new Vue({
        el: '#app-6',
        data: {
        message: 'Hello Vue!'
        }
    })

## 2.6 组件化应用构建

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，
允许我们使用小型、独立和通常可复用的组件构建大型应用。
仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：

![组件](./images/2.1.components.png)

在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。
在 Vue 中注册组件很简单：

    // 定义名为 todo-item 的新组件
    Vue.component('todo-item', {
        template: '<li>这是个待办项</li>'
    })

现在你可以用它构建另一个组件模板：

    <ol>
        <!-- 创建一个 todo-item 组件的实例 -->
        <todo-item></todo-item>
    </ol>

但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。
我们应该能从父作用域将数据传到子组件才对。
让我们来修改一下组件的定义，使之能够接受一个 `prop`：

    Vue.component('todo-item', {
        // todo-item 组件现在接受一个
        // "prop"，类似于一个自定义特性。
        // 这个 prop 名为 todo。
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
    })

现在，我们可以使用 `v-bind` 指令将待办项传到循环输出的每个组件中：



    <div id="app-7">
        <ol>
            <!--
                现在我们为每个 todo-item 提供 todo 对象
                todo 对象是变量，即其内容可以是动态的。
                我们也需要为每个组件提供一个“key”，稍后再
                作详细解释。
            -->
            <todo-item
                v-for="item in groceryList"
                v-bind:todo="item"
                v-bind:key="item.id">
            </todo-item>
        </ol>
    </div>

    Vue.component('todo-item', {
        props: ['todo'],
        template: '<li>{{ todo.text }}</li>'
    })

    var app7 = new Vue({
        el: '#app-7',
        data: {
            groceryList: [
                { id: 0, text: '蔬菜' },
                { id: 1, text: '奶酪' },
                { id: 2, text: '随便其它什么人吃的东西' }
            ]
        }
    })

尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。
子单元通过 prop 接口与父单元进行了良好的解耦。
我们现在可以进一步改进 `<todo-item>` 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。

在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。
在后续教程中我们将详述组件，不过这里有一个 (假想的) 例子，
以展示使用了组件的应用模板是什么样的：

    <div id="app">
        <app-nav></app-nav>
        <app-view>
            <app-sidebar></app-sidebar>
            <app-content></app-content>
        </app-view>
    </div>

## 2.7 与自定义元素的关系

你可能已经注意到 Vue 组件非常类似于自定义元素——它是 [Web 组件规范](https://www.w3.org/wiki/WebComponents/)的一部分，
这是因为 Vue 的组件语法部分参考了该规范。
例如 Vue 组件实现了 [Slot API](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) 与 is 特性。但是，还是有几个关键差别：

 1. Web 组件规范仍然处于草案阶段，并且未被所有浏览器原生实现。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。
 2. Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。