# 编程实践

## 1. x1

## 2. x2

## 3. x3

## 4. x4

## 5. x5

## 6. x6

## 7. x7

## 8. x8

## 9. x9

## 10. x10

## 第 11 章. 不是你的对象不要动

JavaScript 的特殊之处在于任何东西都是可修改的。

默认情况下，你可以修改任何你能访问到的对象，解析器根本不在乎这些对象是开发者定义的还是默认执行环境的一部分。

在一个开发者独自开发的项目中，这不是问题，开发者确切地知道正在修改什么，因为他对所有代码了如指掌；然而，在一个多人开发的项目中，对象的任意修改就是大问题。

### 11.1 什么是你的

你创建（或维护）的对象，才是你拥有的。比如，jQuery 团队拥有 jQuery 对象。

当在项目中使用第三方库（或框架）时，你不是库对象的拥有者。在多人协同开发的项目中，每个人按照官方文档来使用库对象，如果你修改了库对象，则给你的团队设置了一个陷阱，这必将导致一些问题。

请牢记，如果你的代码没有创建这些对象，不要修改它们，包括：

* 原生对象（如 Object、Array）
* DOM 对象（如 document）
* BOM 对象（如 window）
* 类库的对象

上面所有这些对象是你项目执行环节的一部分。你可以直接使用这些对象，而不应该去修改它们。

### 11.2 原则

企业软件需要一致而可靠的执行环节使其方便维护。

在其他语言中，将已存在的对象作为库对象来使用，以完成开发任务；
在 JavaScript 中，将存在的对象作为一种背景（普通对象），在这之上可以做任何事。

但你应该把已存在的 JavaScript 对象作为工具函数库一样来对待：

* 不覆盖方法
* 不新增方法
* 不删除方法

对已存在的对象的修改会导致大量的混乱。

#### 11.2.1 不覆盖方法

在 JavaScript 中，最糟糕的实践是覆盖别人的对象的方法。

遗憾的是，覆盖一个已存在的方法是难以置信的容易，如

```javascript
// 不好的写法
document.getElementById = function() {
  return null; // 引起混乱
};
```

没有任何方法能阻止覆盖 DOM 方法。更严重的是，页面中所有脚本都可以覆盖其他脚本的方法，所有任何脚本都可以覆盖 `document.getElementById()` 方法使其返回 `null`，这会让 JavaScript 库和其他依赖该方法的代码都失效。

也许，你看到过类似下面这样的 “override-plus-fallback” 模式：

```javascript
// 不好的写法
document._originalGetElementById = document.getElementById;
document.getElementById = function(id) {
  if (id === "window") {
    return window;
  } else {
    return document._originalGetElementById(id);
  }
};
```

上例中，将原生 `document.getElementById` 方法保存起来以便后续使用，然后覆盖 `document.getElementById` 。这种方式有时不会调用原生的方法，也许会导致更糟的情况。

#### 11.2.2 不新增方法

在 JavaScript 中为已存在的对象新增方法是很简单的，只需要将一个函数赋值给对象的属性即可。这种做法可以修改所有类型的对象：

```javascript
// 不好的写法：在 DOM 对象上增加了方法
document.getElementById = function() {
  alert("You're awesome");
};

// 不好的写法：在原生对象上增加了方法
Array.prototype.reverseSort = function() {
  return this.sort().reverse();
};

// 不好的写法：在库对象增加了方法
jQuery.doSomething = function() {
  // ...
}
```

几乎不可能阻止你为任何对象添加方法。给不属于自己的对象添加方法会导致命名冲突，一个对象此刻没有某个方法不代表它未来也没有，更糟糕的是如果将来元素的方法和你的方法行为不一致，你将陷入一场代码维护的噩梦。

我们要从 Prototype 类库的发展历史中吸取教训，以修改各种 JavaScript 而著名，它随意地为 DOM 和原生对象增加方法；实际上，它大多数的代码都是在扩展已存在的对象，而不是创建自己的对象。Prototype 的开发者将该库看作是对 JavaScript 的补充。

在 Prototype 1.6 之前，它实现了 `document.getElementsByClassName()`，返回的是原生数组，同时它在数组上也增加了一个方法 `Array.prototype.each()`。

```javascript
document.getElementsByClassName("selected").each(doSomething);
```

而 HTML 5 中标准化了该方法，为此 Prototype 团队增加了一些防守型的代码，如下：

```javascript
if (!document.getElementsByClassName) {
  document.getElementsByClassName = function(classes) {
    // 非原生的实现
  }
}
```

但是，原生的 `document.getElementsByClassName()` 返回的是类数组对象（NodeList），它是没有 `each()` 方法的，所以用户不得不在升级类库的同时，还要修改自己的代码。

从 Prototype 中可以学到，你不可能精确预测 JavaScript 将来会如何变化。大多数 JavaScript 库都有一个插件机制，允许为库带安全地增加一些功能。如果想修改，最好的方式创建一个插件。