# 编程实践

## 1. x1

## 2. x2

## 3. x3

## 4. x4

## 5. x5

## 6. 第 6 章 避免使用全局变量

JavaScript 执行环境在很多方面都有其独特之处。全局变量和函数的使用便是其中之一。

JavaScript 的初始执行环境是由多种多样的全局变量所定义的，这些全局变量在脚本环境创建之初就已经存在了。

我们说这些都是挂载在“全局对象”（global object）上的，“全局对象”是一个神秘的对象，它表示了脚本的最外层上下文。

在浏览器中，`window` 对象往往重载并代理了全局对象，因此任何在全局作用域中声明的变量和函数都是 `window` 对象的属性，比如：

```javascript
var color = 'red';

function getColor() {
  return color;
}

console.log(window.color);
consoel.log(window.getColor());
```

`color`、`getColor` 都是 `window` 对象的属性，即使没有显式挂载。

### 6.1. 全局变量带来的问题

创建全局变量是糟糕的实践。全局变量越多，引入错误的概率将会因此变得越来越高。

#### 6.1.1. 命名冲突

当脚本中的全局变量和全局函数越来越多时，发生命名冲突的概率也随之增高。

所有变量都被定义为局部变量，这样代码才是最容易维护的。

全局函数、全局变量如果分隔到不同的文件，其依赖关系很难追踪到：

```javascript
function getColor() {
  return color; // color 是哪里来的？
}
```

全局环境是用来定义 JavaScript 内置对象的地方，如果你在全局环境定义了变量，则很可能与浏览器附带的内置变量冲突。

#### 6.1.2. 代码的脆弱性

一个依赖于全局变量的函数，与上下文环境深耦合。如果环境发生改变，函数很可能就失效了，如果全局变量 `color` 不存在，`getColor()` 函数会报错。

这意味着，任何对全局环境的变量进修改都可能造成某处代码出错；同样，任何函数也会不经意间修改全局变量，导致对全局变量值的依赖变得不稳定。

当定义函数的时候，最好尽可能多地将数据至于局部作用域。任何来自函数外部的数据都应当以参数形式传进来，这样做可以将函数和外部环境隔离开来，并且在函数内的修改不会影响到程序的其他部分。

#### 6.1.3. 难以测试

任何依赖全局变量才能正常工作的函数，只有为其重新创建完整的全局环境才能正确地测试它。

这意味着，你得同时管理测试、生产情况下的全局环境，一旦全局环境发生变化，则要进行同步。这会增加维护的成本，且越来越难以理清头绪。

确保你的函数不会对全局变量有依赖，这会提高可测试性（testability）。

### 6.2. 意外的全局变量

当你给一个未被声明的变量赋值时，JavaScript 会自动创建一个全局变量，比如：

```javascript
function doSomething() {
  var count = 10;
      title = '哇哈哈'; // 不好的写法：创建了全局变量。
}
```

上面的代码展示了一个常见的错误，不小心将 `,` 敲成了 `;`，造成创建了一个全局变量 `title`。

可使用 JSLint 或 JSHint 来给予警告。

也可启用严格模式，在支持严格模式的环境（IE 10+、Firefox 4+、Chrome）中，给未声明的变量赋值会抛出一个 ReferenceError 错误。