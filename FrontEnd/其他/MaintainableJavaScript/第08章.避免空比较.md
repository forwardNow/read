# 编程实践

## 1. x1

## 2. x2

## 3. x3

## 4. x4

## 5. x5

## 6. x6

## 7. x7

## 8. 避免“空比较”

在 JavaScript 中，我们常常会看到这种代码：变量与 null 的比较（这种用法很有问题），用来判断变量是否被赋予了一个合理的值。比如：

```javascript
var Controller = {
  process: function(items) {
    if (items !== null) { // 不好的写法
      items.sort();
      items.forEach(function(item) {
        // 执行一些逻辑
      });
    }
  }
};
```

`process()` 方法显然希望 `items` 是一个数组，因为 `items` 拥有 `sort()` 和 `forEach()` 方法。

这段代码的意图非常明显：如果参数 `items` 不是一个数组，则停止接下来的操作。但这种写法的问题在于，和 `null` 的比较并不能真正避免错误的发生。`items` 的值可以是 `1`、字符串、任意对象。

仅仅和 `null` 比较并不能提供足够的信息来判断后续代码的执行是否真的安全。

### 8.1. 检测原始值

在 JavaScript 中有 5 种原始类型：字符串、数字、布尔值、`undefined`、`null`。

可以用 `typeof` 验证前 4 种，用 `===` 验证 `null`。

```javascript
typeof 'a';   //=> "string"
typeof 1;     //=> "number"
typeof true;  //=> "boolean"
typeof undefined;     //=> "undefined"

// 可用于未声明的变量
typeof undeclaredVar; //=> "undefined"

typeof null;  //=> "object"
```

简单地和 `null` 比较通常不会包含足够的信息以判断值的类型是否合法。如果所期望的值是 `null`，则可以直接和 `null` 进行比较。

### 8.2. 检测引用值

引用值也称作对象（object），在 JavaScript 中除了原始值之外的值都是引用。

内置的引用类型：Object、Array、Date、Error、RegExp。
对引用类型使用 typeof 运算符返回的都是 `"object"`。

```javascript
typeof {};    //=> "object"
typeof [];    //=> "object"
typeof new Date();      //=> "object"
typeof new RegExp();    //=> "object"

// 这看上去很怪异，被认为是标准规范的严重 bug
typeof null;  //=> "object"
```

通过 `instanceof` 运算符检测某个引用值的类型，基本语法：

```javascript
value instanceof constructor
```

示例：

```javascript
// 检测日期
if (value instanceof Date) {
  console.log(value.getFullYear());
}

// 检测正则表达式
if (value instanceof RegExp) {
  if (value.test(anotherValue)) {
    console.log("Matches");
  }
}

// 检测 Error
if (value instanceof Error) {
  throw value;
}
```

`instanceof` 不仅检测构造函数还检测原型链。所有对象都继承自 `Object`，因此 `引用类型值 instanceof Object; //=> true`。

`instanceof` 运算符也可以检测自定义的类型，比如：

```javascript
function Person(name) {
  this.name = name;
}

var me = new Person("Nicholas");

console.log(me instanceof Object);  //=> true
console.log(me instanceof Person);  //=> true
```