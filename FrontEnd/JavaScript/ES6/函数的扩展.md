# 函数的扩展

## 1. 函数参数的默认值

### 1.1. 基本用法

ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。

```javascript
function log(x, y) {
  // 如果 y 赋值了，但为假值（如 false、0、''），就可以能出错
  y = y || 'World';
  console.log(x, y);
}

// 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。

if (typeof y === 'undefined') {
  y = 'World';
}
```

ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。

```javascript
function log(x, y = 'World') {
  console.log(x, y);
}
```

如果传入 `undefined`，将触发该参数等于默认值，`null` 则没有这个效果。

```javascript
function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
```

### 1.2. 与解构赋值默认值结合使用

参数默认值可以与解构赋值的默认值，结合起来使用。

```javascript
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo() // TypeError: Cannot read property 'x' of undefined
```

如果没给 `foo` 函数传对象参数，则会发生解构错误，通过给对象参数赋予默认值来避免：

```javascript
function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
```

### 1.3. 参数默认值的位置

通常情况下，定义了默认值的参数，应该是函数的尾参数。

如果非尾部的参数设置默认值，实际上这个参数是没法省略的。

```javascript
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]
```

### 1.4. 函数的 length 属性

指定了默认值以后，函数的 `length` 属性只计算默认值参数前面的参数

```javascript
function fn1(a) {
  // do nothing
}
function fn2(a = 5) {
  // do nothing
}
function fn3(a, b, c = 5) {
  // do nothing
}
function fn4(...args) {
  // do nothing
}
function fn5(a = 0, b, c) {
  // do nothing
}
function fn6(a, b = 1, c) {
  // do nothing
}

console.log(fn1.length); // 1
console.log(fn2.length); // 0
console.log(fn3.length); // 2
console.log(fn4.length); // 0
console.log(fn5.length); // 0
console.log(fn6.length); // 1
```

### 1.5. 应用

利用参数默认值，可以指定某一个参数不可省略，如果省略就抛出一个错误。

```javascript
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
```

参数 `mustBeProvided` 的默认值等于 `throwIfMissing` 函数的运行结果（注意函数名t `hrowIfMissing` 之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。

## 2. rest 参数

ES6 引入 rest 参数（形式为 `...变量名`），用于获取函数的多余参数，这样就不需要使用 `arguments` 类数组对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```javascript
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```

`arguments` 对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用 `Array.prototype.slice.call` 先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。

```javascript
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```

rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。

```javascript
// 报错
function f(a, ...b, c) {
  // ...
}
```

## 3. 严格模式

从 ES5 开始，函数内部可以设定为严格模式。

```javascript
function doSomething(a, b) {
  'use strict';
  // code
}
```

ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

```javascript
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```

这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

## 4. name 属性

函数的 `name` 属性，返回该函数的函数名。

这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。

```javascript
// 如果将一个匿名函数赋值给一个变量，
// ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。
var f = function () {};

// ES5
f.name // ""

// ES6
f.name // "f"


// 如果将一个具名函数赋值给一个变量，
// 则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。
const bar = function baz() {};

// ES5
bar.name // "baz"

// ES6
bar.name // "baz"


// Function构造函数返回的函数实例，name 属性的值为 anonymous。
(new Function).name // "anonymous"


// bind返回的函数，name属性值会加上bound前缀。
function foo() {};
foo.bind({}).name // "bound foo"

(function(){}).bind({}).name // "bound "
```