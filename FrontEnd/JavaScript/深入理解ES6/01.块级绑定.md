 # 第一章 块级绑定

在大多数类C语言中，变量（或绑定）总是在它被声明的地方创建；
然而JS的变量实际创建的位置取决于你如何声明它。
ES6能让你更轻易地控制变量的作用域。

## 1. var声明与变量提升

**变量提升（hoisting）**：使用`var`关键字声明的变量，无论实际声明位置在何处，
都被视为在所在函数的顶部声明。

因为 这种特有行为可能导致bug，
所以 ES6引入了块级作用域，让变量的生命周期更加可控，以及与其他语言保持一致。

## 2. 块级声明

**块级声明**：在声明变量的语句块之外无法被访问。

**块级作用域（词法作用域）** 在如下情况被创建：

1. 在一个函数体内部
2. 在一个代码块（“{ }”）内部

### 2.1. let 变量声明

可用 `let` 来代替 `var`，但会将变量的作用域限制在当前代码块中。


### 2.2. const 常量声明

在声明时要求初始化，无法再次赋值。

`const` 声明的对象 不会阻止其成员的修改。

### 2.3. 禁止重复声明

使用 `let`、`const` 在统一作用域内定义一个已有的变量时会抛出错误。

    var message = "hello";

    // 错。同级作用域不能重复声明
    let message = "world";

    // 对。嵌套作用域内会屏蔽外部同名变量
    if ( true ) {
        let message = "haha";
    }

### 2.4. 暂时性死区

    if( condition ) {
        console.info( typeof value ); // 引用错误（运行时错误）
        let value = "blue";
    }

当JS引擎检视接下来的代码块 并发现变量声明时，如果是：
* `var` 声明，则进行声明提升
* `let`/`const` 声明，则将声明放在暂时性死区内

访问暂时性死区内的变量会导致运行时错误。

### 2.5. 全局块级绑定

在全局作用域里用`var`声明变量时，
会创建一个新的全局变量，并成为全局对象`window`的一个属性。

在全局作用域里用`let`/`const`声明变量时，
会在全局作用域上创建新的绑定，但不会添加到`window`且会屏蔽掉`window`的同名属性。

### 2.6. 最佳实践

默认情况下使用 `const` 声明变量，在知道变量需要被更改的情况下才使用 `let`。

理论依据：大部分变量在初始化后都不应当被修改，因为预期外的改动是bug的源头之一。

## 3. 总结

`let`和`const`块级绑定将词法作用域引入了JS。
