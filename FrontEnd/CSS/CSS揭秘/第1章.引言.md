 # 引言

## 1. Web标准

### 1.1. 标准的制定过程

W3C 并不“生产”标准，它扮演的是一个论坛的角色:
W3C 以工作组的方式，把某项技术的相关各方聚集起来，最终由他们来产出标准。

CSS 规范通常是由 CSS 工作组的成员来编写的，人员结构如下：
* 86 名来自 W3C 会员公司的成员(88%)
* 7 名特邀专家(笔者有幸在列)(7%)
* 5 名 W3C 工作人员(5%)

**W3C 会员公司**
 
W3C 会员公司：浏览器厂商、主流网站、研究机构、常规技术公司等。

他们是 Web 标准兴旺发展的直接受益者。

它们每年的会费也是 W3C 的主要资金来源，使得 W3C 能够免费、开放地发布所有技术规范。

对于哪些东西该进入标准，浏览器厂商比 W3C 有更多的发言权。

**每项规范从最初启动到最终成熟，都会经过以下阶段**：
1. 编辑草案(ED)
2. 首个公开工作草案(FPWD)
3. 工作草案(WD)
4. 候选推荐规范(CR)
5. 提名推荐规范(PR)
6. 正式推荐规范(REC)


### 1.2. CSS3、CSS4

**CSS 1**

发表于 1996 年，68 页 A4 纸

**CSS 2**

发表于 1998 年，定义更加严格，囊括了更多的功能，480 页打印纸

**CSS 3**

在 CSS 2 之后，CSS 工作组意识到这门语言已经变得非常庞大，再也无法把它塞进单个规范中了。
这样不仅阅读和编辑极其困难，而且限制了 CSS 本身的快速发展。

因此，将 CSS 打散到多个不同的规范（模块）中，每个模块都可以独立更新版本。

那些延续 CSS 2.1 已有特性的模块 会升级到 3 这个版本号。比如以下模块:
* CSS 语法（ http://w3.org/TR/css-syntax-3 ）
* CSS 层叠与继承（ http://w3.org/TR/css-cascade-3)
* CSS 颜色（ http://w3.org/TR/css3-color ） 
* 选择符（http://w3.org/TR/selectors）
* CSS 背景与边框（http://w3.org/TR/css3-background）
* CSS 值与单位（http://w3.org/TR/css-values-3）
* CSS 文本排版（http://w3.org/TR/css-text-3）
* CSS 文本装饰效果（http://w3.org/TR/css-text-decor-3）
* CSS 字体（http://w3.org/TR/css3-fonts）
* CSS 基本 UI 特性（http://w3.org/TR/css3-ui）

**新概念/新规范**

如果某个模块是前所未有的新概念，那它的版本号将从 1 开始。 比如下面这些:
* CSS 变形(http://w3.org/TR/css-transforms-1)
* 图像混合效果(http://w3.org/TR/compositing-1)
* 滤镜效果(http://w3.org/TR/filter-effects-1)
* CSS 遮罩(http://w3.org/TR/css-masking-1)
* CSS 伸缩盒布局(http://w3.org/TR/css-flexbox-1)
* CSS 网格布局(http://w3.org/TR/css-grid-1)

尽管“CSS3”这个名词非常流行，但它实际上并没有在任何规范中定义过。

“CSS3”指的是一个非正式的集合，
它包括 CSS 规范第三版(Level 3)再加上一些版本号还是 1 的新规范。

由于 CSS 的各个模块在近些年里以不同的速度在推进，
我们已经越来越难以把这些规范以 CSS3、CSS4 这样的方式来划分了，
而且这样也难以被大众理解和接受。

### 1.3. 浏览器前缀

**滥用浏览器前缀**

开发者人地加上所有可能的浏览器前缀，再把无前缀的版本放在最后，以图一劳永逸。
我们最终写出的代码可能就是这样的:

    -moz-border-radius: 10px; 
    -ms-border-radius: 10px; 
    -o-border-radius: 10px; 
    -webkit-border-radius: 10px; 
    border-radius: 10px;


这里面有两条声明是完全多余的: `-ms-border-radius` 和 `-o-border-radius `。
这两个属性从来没有在任何浏览器中出现过，
因为 IE 和 Opera 从一开始就是直接实现 `border-radius` 这个无前缀版本的。

把每个声明都重复五遍是相当枯燥的，而且很难维护。
因此出现某个工具来把这项工作自动化：
* Autoprefixer(https://github.com/ai/autoprefixer) 采用 Can I Use... (http://caniuse.com) 的数据库来判断哪些前缀是需要添加的;此外，它是在本地完成编译的，类似预处理器。
* -prefix-free(http://leaverou.github.io/prefixfree) 会在浏览器中进行特性检测，来决定哪些前缀是需要的。
*  Stylus(http://stylus-lang.com/) 、LESS(http://lesscss.org) 或 Sass(http://sass-lang.com) 的预处理器并不自带任何加前缀的方法， 但很多人开发过一些能为常用属性加前缀的 mixin;社区中也有一些 库提供了这类 mixin。

## 2. CSS 编码技巧

### 2.1. 尽量减少代码重复

在软件开发中，保持代码的 DRY 和可维护性是最大的挑战之一，而这句话对 CSS 也是适用的。

在实践中，代码可维护性的最大要素是尽量减少改动时要编辑的地方。

举例来说，如果在变大一个按钮时需要在一堆规则中进行 10 处修改，那就很可能会漏改其中某处，当你在给别人善后时更是如此。即使这些要修改的地方很明显，或者最终可以找齐它们，但你还是浪费了时间，原本可以利用这些时间来做点更有意义的事情。

而且，这还不仅仅是后期修改的问题。灵活的 CSS 通常更容易扩展: 在写出基础样式之后，只用极少的代码就可以扩展出不同的变体，因为只需覆盖一些变量就可以了。

先来看看下面这段 CSS，它给按钮添加了一些效果：

    .btn-1 {
        padding: 6px 16px;
        border: 1px solid #446d88;
        background: #58a linear-gradient(#77a0bb, #58a);
        border-radius: 4px;
        box-shadow: 0 1px 5px gray;
        color: white;
        text-shadow: 0 -1px 1px #335166;
        font-size: 20px;
        line-height: 30px;
    }

**当某些值相互依赖时，应该把它们的相互关系用代码表达出来**

    /* 
        依赖字号进行缩放 盒模型相关属性。
        （使用父级的字号用em，使用根级的字号用rem）
    */
    .btn-2 {
        padding: .3em .8em;
        border: 1px solid #446d88;
        background: #58a linear-gradient(#77a0bb, #58a); border-radius: .2em;
        box-shadow: 0 .05em .25em gray;
        color: white;
        text-shadow: 0 -.05em .05em #335166;
        font-size: 125%; 
        line-height: 1.5;
    }


**此时就需要重新审视到底哪些效果应该跟着按钮一起放大，而哪些效果是保持不变的。**

    /*
        按钮的边框粗细保持在 1px，不受按钮尺寸的影响
        把半透明的黑色或白色叠加在主色调上，即可产生主色调的亮色和暗色变体
    */
    padding: .3em .8em;
    border: 1px solid rgba(0,0,0,.1);
    background: #58a linear-gradient(hsla(0,0%,100%,.2),
                                    transparent);
    border-radius: .2em;
    box-shadow: 0 .05em .25em rgba(0,0,0,.5); color: white;
    text-shadow: 0 -.05em .05em rgba(0,0,0,.5);

只要覆盖 background-color 属性，就可以得到不同颜色版本 的按钮了:

    button.cancel { 
        background-color: #c00; 
    }
    button.ok { 
        background-color: #6b0; 
    }


**代码易维护 vs. 代码量少**

代码易维护和代码量少不可兼得，比如 为一个元素添加一道 10px 宽的边框，但左侧不加边框。

    // 只要一条声明就搞定，但以后要改变尺寸，则需要修改三处
    border-width: 10px 10px 10px 0;

    // 把它拆成两条声明的话，改起来就容易多了，而且可读性或许更好一些
    border-width: 10px; 
    border-left-width: 0;

**currentColor**

在 CSS 颜色(第三版)(http://w3.org/TR/css3-color) 规范中，
有个特殊的颜色关键字 `currentColor`，
这个关键字并没有绑定到一个固定的颜色值，而是一直被解析为 color 的值。

    // 让所有的水平分割线自动与文本的颜色保持一致
    hr {
        height: .5em;
        background: currentColor; 
    }

**继承**

`inherit` 可以用在任何 CSS 属性中，
而且它总是绑定到父元素的计算值(对伪元素来说，则会取生成该伪元素的宿主元素)。

    // 把超链接的颜色设定为与页面中其他文本相同
    a { color: inherit; }

    // 创建提示框的时候，小箭头能够自动继承背景和边框的样式
    .callout { position: relative; }
    .callout::before { content: "";
        position: absolute;
        top: -.4em; 
        left: 1em; 
        padding: .35em; 
        background: inherit; 
        border: inherit; 
        border-right: 0; 
        border-bottom: 0; 
        transform: rotate(45deg);
    }

### 2.2. 相信你的眼睛，而不是数字

有时候精准的尺度看起来并不精准，而我们的设计需要顺应这种偏差。
举一个在视觉设计领域广为人知的例子吧：
我们的眼睛在看到一个完美垂直居中的物体时，会感觉它并不居中。 
实际上，我们应该把这个物体从几何学的中心点再稍微向上挪一点，才能取得理想的视觉效果。

与此类似，在字体设计领域广为人知的是，圆形的字形(比如 0)与矩形字形相比，
需要稍微放大一些，因为我们倾向于把圆形感知得比其实际尺寸更小一些。

**这些视觉上的错觉在任何形式的视觉设计中都普遍存在，需要我们有针对性地进行调整。**
一个非常常见的例子是给一个文本容器设置内边距。
不论内容文本有多长，是一个单词还是几个段落，这个问题都会出现。
假如我们给容器的四边指定相同的内边距，则实际效果看起来并不相等。
原因在于，字母的形状在两端都比较整齐，而顶部和底部则往往参差不齐，
从而导致你的眼睛把这些参差不齐的空缺部分感知为多出来的内边距。
因此，如果我们希望四边的内边距看起来是基本一致的，就需要减少顶部和底部的内边距。

### 2.3. 关于响应式网页设计

响应式网页设计(Responsive Web Design，RWD)，
人们大多只是在不停念叨网页的“响应式”是多么重要，而极少有人去深入探讨怎样才能做好响应式设计。

比较常见的实践是用多种分辨率来测试一个网站，
然后添加越来越多的媒体查询(Media Query)规则来修补网站在这些分辨率下出现的问题。
然而对于今后的 CSS 改动来说，**每个媒体查询都会增加成本**，而这种成本是不应轻易上升的。未来每次对 CSS 代码的修改都要求我们逐一核对这些媒体查询是否需要配合修改，甚至可能要求我们反过来修改这些媒体查询的设置。这一点常常被我们忽略，后患无穷。你添加的媒体查询越多，你的 CSS 代码就会变得越来越经不起折腾。

这并不是说媒体查询是一种不良实践。**只要用对了，它就是利器**。但是，你只应该把它作为最后的手段。比如你想把网站做得弹性灵活，但其他尝试全都失败了;或者我们希望在较大或较小的视口下完全改变网站的设计形态(譬如，把侧栏改成水平布局)。我这么说的原因在于，媒体查询不能以一种连续的方式来修复问题。它们的工作原理基于某几个特定的阶梯(亦称“断点”)，如果大部分样式代码并不是以弹性的方式来编写的，那么媒体查询能做的只是修补某个特定分辨率下的特定问题——这本质上只是把垃圾扫到床底下而已。

当然，有一点上面并没有提到，**媒体查询的断点不应该由具体的设备来决定**，而应该根据设计自身来决定。这不仅是因为我们的网站需要面向的设备太多了(尤其是考虑到未来的设备时)，还因为一个网站在桌面端可能会以任意尺寸的窗口来显示。如果你有信心自己的设计在任何可能出现的视口尺寸下都能良好工作，谁关心这些设备的分辨率具体是多少呢?

遵从“尽量减少代码重复”所描述的原则对此也是有帮助的，因为你不需要去覆盖媒体查询里同样数量的声明。这在本质上减轻了它们所产生的维护成本。

下面还有一些建议，可能会帮你避免不必要的媒体查询。
* 使用百分比长度来取代固定长度。如果实在做不到这一点，也应该尝试使用与视口相关的单位(vw、vh、vmin 和 vmax)，它们的值解析为视口宽度或高度的百分比。
* 当你需要在较大分辨率下得到固定宽度时，使用 `max-width` 而不是 `width`，因为它可以适应较小的分辨率，而无需使用媒体查询。
* 不要忘记为替换元素(比如 img、object、video、iframe 等)设置一个 `max-width`，值为 100%。
* 假如背景图片需要完整地铺满一个容器，不管容器的尺寸如何变化， `background-size: cover` 这个属性都可以做到。但是，我们也要时刻牢记——带宽并不是无限的，因此在移动网页中通过 CSS 把一张大图缩小显示往往是不太明智的。
* 当图片(或其他元素)以行列式进行布局时，让视口的宽度来决定列的数量。弹性盒布局(即 Flexbox)或者 `display: inline-block` 加上常规的文本折行行为，都可以实现这一点。
* 在使用多列文本时，指定`column-width`(列宽)而不是指定 `column-count`(列数)，这样它就可以在较小的屏幕上自动显示为单列布局。

总的来说，我们的思路是尽最大努力**实现弹性可伸缩的布局，并在媒体查询的各个断点区间内指定相应的尺寸**。当网页本身的设计足够灵活时，让它变成响应式应该只需要用到一些简短的媒体查询代码。Basecamp 的设计师在 2010 年写到过这种非常规情况。

>“结果我们发现，想让网页在一堆不同的设备上合理展示，只需要在最终产品上添加一点 CSS 媒体查询就可以了。这件事情之所以这么简单，关键在于我们的布局原本就是弹性可伸缩的。因此，优化网页在小屏幕上的表现，其实只意味着把一些外边距收拢到最小程度，然后把因为屏幕太窄而无法显示成双列的侧栏调整为单列布局而已。” <br>   
——在 Iterations 中实践响应式设计(http://signalvnoise.com/posts/2661-experimenting-with-responsive-design-in-iterations)

如果你发现自己需要一大堆媒体查询才能让设计适应大大小小的屏幕，那么不妨后退一步，重新审视你的代码结构。因为在所有的情况下，响应式都不是唯一需要考虑的问题。

### 2.4. 合理使用简写

    background: rebeccapurple; 
    background-color: rebeccapurple;

合理使用简写是一种良好的防卫性编码方式，可以抵御未来的风险。
当然，如果我们要明确地去覆盖某个具体的展开式属性并保留其他相关样式，那就需要用展开式属性

展开式属性与简写属性的配合使用也是非常有用的，可以让代码更加 DRY。

    background: url(tr.png) no-repeat top right / 2em 2em, 
                url(br.png) no-repeat bottom right / 2em 2em,
                url(bl.png) no-repeat bottom left / 2em 2em;

如果只为某个属性提供一个值，那它就会扩散并应用到列表中的每一项。

    background: url(tr.png) top right, 
                url(br.png) bottom right,
                url(bl.png) bottom left; 
    background-size: 2em 2em;
    background-repeat: no-repeat;

现在，我们只需要在一处修改，就可以改变所有的 `background-size` 和 `background-repeat` 了。你会发现这个技巧在本书中的使用非常普遍。

### 2.5. 我应该使用预处理器吗

Stylus(http://stylus-lang.com/) 、Sass(http://sass-lang.com/) 或 LESS(http://lesscss.org/) 这样的 CSS 预处理器。它们为 CSS 的编写提供提供了一些便利，比如变量、mixin、函数、规则嵌套、颜色处理等。

**如果使用得当，它们在大型项目中可以让代码更加灵活**，而 CSS 自身 在这方面确实有很大局限。只要我们在代码健壮性、灵活性和 DRY 方面有追求，就会感受到 CSS 在这方面的局限。不过，预处理器也不是完美无缺的。
* CSS的 **文件体积和复杂度** 可能会失控。即使是简洁明了的源代码，在经过编译之后也可能会变成一头从天而降的巨兽。
* **调试难度会增加**，因为你在开发工具中看到的 CSS 代码并不是你写的源代码。不过这个问题已经大大好转了，因为已经有越来越多的调试工具开始支持 SourceMap。SourceMap 是一种非常酷的新技术， 正是为了解决这个痛点而生的，它会告诉浏览器哪些编译生成的 CSS 代码对应哪些预处理器 CSS 代码，精确到行号。
* 预处理器在开发过程中引入了一定程度的 **延时**。尽管它们通常很快， 但仍然需要差不多一秒钟的时间来把你的源代码编译成 CSS，而你不得不等待这段时间才能预览到代码的效果。
* 每次抽象都必然会带来更高的学习成本，每当有新人加入到我们的代码库中，这个问题都会重演。他要么已经对我们选择的这门预处理器“方言”很熟悉，要么得从头学。这意味着我们要么强制协作者接受我们的选择，要么花费额外的时间来培训，而这两者都不是我们想要的。

除了上面列出的这些问题，预处理器还可能导致这种风险:网站开发者可能会不自觉地“依赖”和“滥用”。因为在某些时候，预处理器并不必要。比如在小型项目中;或者在未来，说不定预处理器最受欢迎的那些特性都被加入了原生 CSS 中。很惊讶吗?没错，很多受预处理器启发的特性都已经以各种方式融入到原生 CSS 中了。

* 有一份关于(跟变量类似的)自定义属性的草案，叫作 CSS 自定义属性暨层叠式变量(http://w3.org/TR/css-variables-1) 。
* CSS 值与单位(第三版)中的 calc() 函数，不仅在处理运算时非常强大，而且已经得到了广泛的支持，当下可用。
* CSS 颜色(第四版)(http://dev.w3.org/csswg/css-color)引入的 color() 函数会提供颜色运算方法。
* 关于嵌套，CSS 工作组内部正在进行一些正式的讨论，甚至以前还有过一份相关的草案(ED)。

我的建议是，在每个项目开始时使用纯 CSS，只有当代码开始变得无法保持 DRY 时，才切换到预处理器的方案。为了避免可能发生的“依赖”或“滥用”，在引入预处理器的问题上需要冷静决策，不应该在每个项目一开始时就不动脑筋顺着惯性来。



