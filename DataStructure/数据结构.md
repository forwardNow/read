# 数据结构和算法

## 1. 绪论

什么是数据结构：

* 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科
* 程序设计 = 数据结构 + 算法
* 数据结构就是关系，就是数据元素相互之间存在的一种或多种特定关系的集合

逻辑结构和物理结构：

* 传统上，我们把数据结构分为逻辑结构和物理结构
* 逻辑结构：是指数据对象中数据元素之间的相互关系，也是我们今后最需要关注和讨论的问题
* 物理结构：是指数据的逻辑结构在计算机中的存储形式

四大逻辑结构：

* 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他不三不四的关系。
* 线性关系：线性结构中的数据元素之间是一对一的关系。
* 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系
* 图形结构：图形结构的数据元素是多对多的关系

物理结构：

* 研究的是如何把数据元素存储到计算机中的存储器中
* 存储器主要是针对内存而言，硬盘灯外部存储器的数据组织通常用文件结构来描述
* 数据元素的存储结构形式有两种：顺序存储和链式存储

顺序存储结构：

* 是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的
* 比如编程语言的数组结构

链式存储结构：

* 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
* 链式存储结构的数据元素存储物理关系不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。

## 2. 浅谈算法

数据结构和算法是一对好基友，只谈数据结构的话，我们在很短的时间内就可以把几种重要的数据结构学习完。但不知道这些数据结构有啥用处，如果把相应的算法结合起来学习则会相得益彰。

比如求等差数列的和 1 + 2 + 3 + ... + 99 + 100 = ?：

* 方式一
  
  ```c
  int i, sum = 0, n = 100;
  for (i = 1; i <= n; i++)
  {
    sum = sum + i;
  }
  printf("%d", sum);
  ```

* 方式二

  ```c
  int i, sum = 0, n = 100;
  sum = (1 + n) * n / 2;
  printf("%d", sum);
  ```

算法：

* 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
* 算法就是你泡妞的技巧和方式
* 对于给定的问题，是可以有多种算法来解决的

算法具有五个基本特征：输入、输出、有穷性、确定性、可行性

* 输入：零个或多个输入（参数）
* 输出：一个或多个输出，输出的形式可以是打印输出，也可以是返回一个或多个值
* 有穷性：算法在执行有限的步骤后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成
* 确定性
  * 算法的每个一个步骤都具有确定的含义，不会出现二义性
  * 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果
  * 算法的每个步骤都应该被精确定义而无歧义
* 可行性
  * 算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成

算法设计的要求：

* 正确性
  * 算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案
  * 大体分为以下四个层次
    * 算法程序没有语法错误
    * 算法程序对于合法输入能够产生满足要求的输出
    * 算法程序对于非法输入能够产生满足规格的说明
    * 算法程序对于故意刁难的测试输入都有满足要求的输出结果
* 可读性
  * 算法设计另一目的是为了便于阅读、理解、交流
  * 我们写代码的目的，一方面是为了让计算机执行，但还有一个重要的目的是为了便于他人阅读和自己日后阅读修改
* 健壮性
  * 当输入数据不合法时，算法也能做出相关处理，而不是产生异常、崩溃或莫名其妙的结果
* 时间效率高和存储量低
  * 生活中，每个男人都希望找一个贤惠的老婆，她们温柔又体贴，美丽有大方，还会做一手好菜
  * 好算法就犹如好老婆，应该具备时间效率高和存储量低的特点。所以在设计算法的时候我们应该尽量思考这两方面的问题

## 3. 时间复杂度和空间复杂度

引入：

* 效率高一般指的是算法的执行时间，那么我们如何度量一个算法的执行时间呢？
* 比较容易想到的方法就是把算法跑若干次，然后拿个“计时器”在旁边计时。

事后统计方法：

* 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低
* 缺陷：
  * 必须依据算法事先编制好测试程序，通常需要花费大量时间和精力，完了发觉测试的是糟糕的算法，那不是功亏一篑
  * 不同的测试环境差别大

事前分析估算方法：

* 在计算机程序编写前，依据统计方法对算法进行估算

经过总结，我们发现一个高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

* 算法采用的策略、方案
* 编译产生的代码质量（跟编译器的优劣有关）
* 问题的输入规模 （输入流的多少）
* 机器执行指令的速度

也就是说，一个程序的运行时间依赖于算法的好坏和问题的输入规模。

我们在分析一个算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来。

判断一下两个算法A、B的优劣：

* 假设A、B的输入规模都是 n
* A 要做 2n + 3 次操作：n次循环 -> n次循环 -> 3次运算
* B 要做 3n + 1 次操作：n次循环 -> n次循环 -> n次循环 -> 1次运算

函数的渐近增长

* 给定两个函数 f(n)、g(n)，如果存在一个整数 N，使得对于所有的 n > N，f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)

判断一个算法的效率时，函数中的常数和其它次要项常常可以忽略，而更应该关注主项（最高项）的阶数：

* 3n + 1 -> n
* 2n^2 + 3n + 1 -> n^2

算法时间复杂度的定义：

* 在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作： T(n) = O(f(n))。
它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简程为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。
* 也就是说，执行次数 等于 时间
* 用 O() 来体现算法时间复杂度记法，称之为大 O 记法
  * 3n + 1 -> O(n)
  * 2n^2 + 3n + 1 => O(n^2)

推导大 O阶：

* 用常数 1 取代运行时间中的所有加法常数
  * 3n + 2 + 1 -> 3n + 1
* 在修改后的运行次数函数中，只保留最高次项
  * 3n + 1 -> 3n
* 如果最高项存在且不是 1，则去除与这个项相乘的常数
  * 3n -> O(n)

线性阶：

* 线性阶就是随着问题规模 n 的扩大，对应计算次数呈直线增长
* 一般含有非嵌套循环（即单个循环结构）涉及线性阶
* 比如

  ```c
  int i, n = 100, sum = 0;
  for (i = 0; i < n; i++)
  {
    sum = sum + i;
  }
  ```

* 上面的代码，时间复杂度为 O(n)

平方阶：

* 两个循环进行嵌套，O(n^2)
* 三个循环进行嵌套，O(n^3)
* 示例

  ```c
  int i, j, n = 100;
  for (i = 0; i < n; i++)
  {
    for (j = i; j < n; j++)
    {
      printf("wahh");
    }
  }
  ```

  * 内层循环执行次数：n + (n - 1) + (n - 2) + ... +  1 = n × ( n + 1) / 2
  * n × (n + 1) / 2 = 0.5 × n^2 + 0.5 -> O(n^2)

指数阶：

* 示例

  ```c
  int i = 1, n = 100;
  while(i < n)
  {
    i = i * 2;
  }
  ```

* 设 x 为循环次数，每次循环都乘以 2，当 x^2 >= n 时，退出
* 则 x = log(2)n
* 时间复杂度为 O(logn)

函数调用的时间复杂度分析：

* 示例 1

  ```c
  int i, j;
  for (i = 0; i < n; i++) {
    function(i);
  }
  void function(int count) {
    int j;
    for (j = count; j < n; j++)
      printf("%d", j);
  }
  ```

* 时间复杂度为 O(n^2)

常见的时间复杂度：

* 常数阶，O(1)，示例：1234
* 线性阶，O(n)，示例：3n + 4
* 对数阶，O(logn)，示例：3log(2)n + 4
* nlogn阶，O(nlogn)，示例：2n + 3nlog(2)n + 1
* 平方阶，O(n^2)，示例：3n^2 + 4n + 1
* 立方阶，O(n^3)，示例：3n^3 + 2n^2 + 4n + 1
* 指数阶，O(2^n)，示例：2^n

耗费的时间从小到大：

* O(1)
* O(logn)
* O(n)
* O(nlogn)
* O(n^2)
* O(n^3)
* O(2^n)
* O(n!)
* O(n^n)

最坏的情况与平均情况：

* 从心理学角度讲，每个人对将来要发生的事情都会有一个预期。比如半杯水，有人会高兴地说“哇，还有半杯”，也有人会失望得说“天，只有半杯了”。
* 算法分析也是类似，比如在 n 个数字中查找数字 x，最好的情况是第一个数字就是，时间复杂度为O(1)，最坏的情况就是该数字在最后一个位置，时间复杂度为 O(n)
* 平均运行时间是期望的运行时间
* 最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

算法的空间复杂度：

* 我们在写代码时，完全可以用空间来换时间
* 比如，判断某年是否为闰年：
  * 方法一，给定的年份，通过算法计算得到是否为闰年
  * 方法二，创建一个有 2050 个元素的数组，从 0001 年到 2050 年，如果该年是闰年则元素的值为 1，否则为 0，这样通过判断索引就能知道是否为闰年
* 方法一，需要经过一系列的计算，但是省空间
* 方法二，需要大量的控件，但每次查询只需要一次索引判断就行
* 这就是通过一笔空间上的开销来换取计算时间开销的小技巧
* 计算公式： S(n) = O(f(n))，n 为问题的规模，f(n)为语句关于 n 所占存储空间的函数
* 通常，我们都是用”时间复杂度“来指运行时间的需求，用”空间复杂度“指空间需求
* 当直接要让我们求”复杂度“时，通常指的是时间复杂度
* 显然对时间复杂度的追求更是属于算法的潮流

## 4. 线性表

线性表（List）：

* 由零个或多个数据元素组成的有限序列
* 关键点
  * 序列：元素是有顺序的
  * 前驱和后继：若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他元素都有且只有一个前驱和后继
  * 有限：线性表的元素是有限个的

用数学语言来进行定义：

* 可表示为：a(1), a(2), ... , a(i-1), a(i), a(i+1), ... , a(n)
* a(i-1) 是 a(i) 的直接前驱元素
* a(i+1) 是 a(i) 的直接后继元素
* 线性表的个数 n（n > 0）为线性表的长度
* 当 n = 0 时，称为空表

数据类型：

* 是值一组性质相同的值的集合，及定义在此集合上的一些操作的总称
* 如编程语言中的 整型、浮点型、字符型 这些都是数据类型
* 计算机中，内存是有限的
  * 1 + 1 = 2 这样的整形数字的运算不需要开辟很大的内存空间
  * 1.23456789 + 2.34567891 的计算需要开辟比较大的空间才存放得下
* 对数据类型进行分类，分出多种数据类型来适合各种不同的计算条件差异
* 例如在 C 语言中，按照取值的不同，数据类型可以分为两类：
  * 原子类型：不可以再分解的基本类型，如整形、浮点型、字符型
  * 结构类型：由若干个类型组合而成，是可以再分解的，如整形数组是由若干整形数据组成的

抽象：

* 是指抽取出事物具有的普遍性本质。它要求抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节。

抽象数据类型：

* 对已有的数据类型进行抽象，就有了抽象数据类型
* 抽象数据类型（Abstract Data Type，ADT）是指一个数学模型及定义在该模型上的一组操作
* 抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关
* 比如 1 + 1 = 2 的操作，在不同的 CPU 的处理上可能不一样，但由于其定义的数学特性相同，所以在计算机编程者看来，它们都是相同的。
* ”抽象“的意义在于数据类型的数学抽象特性
* 而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是计算机编程者在设计软件程序时自己定义的数据类型
* 例如，一个 3D 游戏中，要定位角色的位置，需要 x、y、z 三个整型数据组合在一起的坐标。我们可以定义一个 point 的抽象数据类型，它拥有 x、y、z 三个整型变量，这样我们就可以很方便地对一个角色的位置进行操作。
* 为了便于对抽象数据类型进行规范的描述，给出一种描述抽象数据类型的标准格式：

  ```text
  ADT 抽象数据类型名称
  Data
    数据元素之间逻辑关系的定义
  Operation
    操作
  endADT
  ```
