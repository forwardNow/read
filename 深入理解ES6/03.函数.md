 # 函数

在ES5函数之上，进行增量改进。

## 1. 参数默认值

参数默认值 让函数在接收到的参数数量不足时行为更清晰。

### 1.1. JS函数的特点

调用时可接受任意数量的参数，而无视函数声明处的参数数量。

### 1.2. ES5中模拟

利用逻辑或运算符（`||`），当左侧的值为假时，返回右侧的操作数。

    function makeRequest( url, timeout, calback ) {
        // 方式一
        timeout = timeout || 3000;

        // 方式二 
        timeout = ( typeof timeout !== "undefined" ) ?
                  timeout : 3000;  
    }

方式一：如果传给 timeout 的值是 0，则会出错。

方式二：公共模式。

### 1.3. ES6中的参数默认值

未给参数传值，才会使用默认值。

给参数传值了（就算是 `null` 或 `undefined`），则不使用默认值。

    function makeRequest( url, timeout = 3000, calback ) {

    }

参数默认值是一个表达式，这意味着，可以是一个函数调用

    function getValue() {
        return Math.random();
    }
    function add( first, second = getValue() ) {
        return first + second;
    }

## 2. 剩余参数

**说明**：

解决传入的参数过多的情况，替换 `arguments`。

**语法**：

三个点（`...`）与一个紧跟着的具名参数 组成，是数组类型。

**示例**：

    function foo( name, args... ) {
        // ...
    }

**限制**：
* 一个函数只能有一个剩余参数，且必须放在最后
* 不能再 setter 中使用

## 3. 扩展运算符

**语法**：

在数组前面加 `...`。

**说明**：

避免使用`apply()`混淆代码的真实意图。

JS引擎会将数组分割为独立参数传递进去。

**示例**：

    let values = [1, 2, 3, 5, 4];

    // 以前
    Math.max.apply( Math, values ); //=> 5
    // 现在
    Math.max(...values); //=> 5
    Math.max(...values, 10); //=> 10

## 4. 函数的名称属性

ES6给所有函数添加了 `name` 属性，以解决各种函数定义方式造成调试困难的问题。

示例：

    function fnA() {};
    fnA.name; //=> "fnA"

    let fnB = function () {};
    fnB.name; //=> "fnB"

    // setter函数 会有 "set" 前缀
    // bind()创建的函数 会有 "bound" 前缀
    // Function 构造器创建的函数 会有 "anonymous" 前缀

## 5. 明确函数的用途

**用途**：

* 普通函数，用于调用
* 构造函数，创建对象

`new`：

函数根据是否使用 `new` 来调用，而有双重用途。

当用`new`来调用时，函数内部的`this`是一个新对象，并作为函数的返回值。

**区分**

通过首字母是否大写来区分是否用`new`来调用，如 `Person`、`getPersonName`。

**机制**

JS为函数提供了两个不同的内部方法：
* `[[call]]`：当函数未使用`new`调用时，`[[call]]`会被执行，运行的是函数体里的代码。
* `[[constructor]]`：当使用`new`调用时，`[[constructor]]`会被执行，负责创建一个新对象，并将新最新作为`this`去执行函数体

**ES6**

新增 `new.target` 从而消除函数调用的不确定性。

    function Person( name ) {
        if ( typeof new.target !== "undefined" ) {
            this.name = name; // 使用 new 调用
        }
    }