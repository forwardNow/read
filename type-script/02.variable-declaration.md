 # 变量声明

`const`是对`let`的一个增强，它能阻止对一个变量再次赋值。

## 1. var 声明

一直以来我们都是通过`var`关键字定义JavaScript变量。

    var a = 10;

## 2. 作用域规则

多次声明同一个变量并不会报错

## 3. 捕获变量怪异之处

    for (var i = 0; i < 10; i++) {
        setTimeout(function() { console.log(i); }, 100 * i);
    }

    for (var i = 0; i < 10; i++) {
        // capture the current state of 'i'
        // by invoking a function with its current value
        (function(i) {
            setTimeout(function() { console.log(i); }, 100 * i);
        })(i);
    }

## 4. let 声明

除了名字不同外，`let`与`var`的写法一致。

    let hello = "Hello!";

主要的区别不在语法上，而是语义，我们接下来会深入研究。

### 4.1. 块作用域

当用`let`声明一个变量，它使用的是词法作用域或块作用域。 
不同于使用`var`声明的变量那样可以在包含它们的函数外访问，
块作用域变量在包含它们的块或`for`循环之外是不能访问的。

在`catch`语句里声明的变量也具有同样的作用域规则。

    try {
        throw "oh no!";
    }
    catch (e) {
        console.log("Oh well.");
    }

    // Error: 'e' doesn't exist here
    console.log(e);

我们不能在`let`语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。

    a++; // illegal to use 'a' before it's declared;
    let a;

### 4.2. 重定义及屏蔽

    let x = 10;
    let x = 20; // 错误，不能在1个作用域里多次声明`x`

### 4.3. 块级作用域变量的获取

当`let`声明出现在循环体里时拥有完全不同的行为。 
不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域。 
这就是我们在使用立即执行的函数表达式时做的事，
所以在`setTimeout`例子里我们仅使用`let`声明就可以了。

    for (let i = 0; i < 10 ; i++) {
        setTimeout(function() {console.log(i); }, 100 * i);
    }
    //=> 0,1,2,3,......,7,8,9

## 5. const 声明

`const` 声明是声明变量的另一种方式。

    const numLivesForCat = 9;

它拥有与`let`相同的作用域规则，但是不能对它们重新赋值。

## 6. let vs. const

使用[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)，
所有变量除了你计划去修改的都应该使用`const`。 
基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，
并且要思考为什么会需要对这些变量重新赋值。 
使用`const`也可以让我们更容易的推测数据的流动。

## 7. 解构

Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 
完整列表请参见 [the article on the Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。

### 7.1. 解构数组

最简单的解构莫过于数组的解构赋值了：

    let input = [1, 2];
    let [first, second] = input;
    console.log(first); // outputs 1
    console.log(second); // outputs 2

这创建了2个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：

    first = input[0];
    second = input[1];

解构作用于已声明的变量会更好：

    // swap variables
    [first, second] = [second, first];

作用于函数参数：

    function f([first, second]: [number, number]) {
        console.log(first);
        console.log(second);
    }
    f(input);

你可以在数组里使用`...`语法创建剩余变量：

    let [first, ...rest] = [1, 2, 3, 4];
    console.log(first); // outputs 1
    console.log(rest); // outputs [ 2, 3, 4 ]

当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：

    let [first] = [1, 2, 3, 4];
    console.log(first); // outputs 1

或其它元素：

    let [, second, , fourth] = [1, 2, 3, 4];

### 7.2. 对象解构

你也可以解构对象：

    let o = {
        a: "foo",
        b: 12,
        c: "bar"
    };
    let { a, b } = o;

这通过 `o.a` and `o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。

就像数组解构，你可以用没有声明的赋值：

    ({ a, b } = { a: "baz", b: 101 });

注意，我们需要用括号将它括起来，因为Javascript通常会将以 `{` 起始的语句解析为一个块。
你可以在对象里使用`...`语法创建剩余变量：

    let { a, ...passthrough } = o;
    let total = passthrough.b + passthrough.c.length;

**要小心使用解构。** 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。