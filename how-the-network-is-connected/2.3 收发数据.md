# 2.3 收发数据

# 2.3.1 将 HTTP 请求消息交给协议栈

当控制流程从 connect 回到应用程序之后,接下来就进入数据收发阶段了。

数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的(图 2.3③),
协议栈收到数据后执行发送操作,这一操作包含如下要点。

首先,协议栈并不关心应用程序传来的数据是什么内容。
应用程序在调用 write 时会指定发送数据的长度,

在协议栈看来,要发送的数据就是一定长度的二进制字节序列而已。

其次,协议栈并不是一收到数据就马上发送出去,
而是会将数据存放在内部的发送缓冲区中,并等待应用程序的下一段数据。

这样做是有道理的。

应用程序交给协议栈发送的数据长度是由应用程序本身来决定的,
不同的应用程序在实现上有所不同,有些程序会一次性传递所有的数据,
有些程序则会逐字节或者逐行传递数据。

总之,一次将多少数据交给协议栈是由应用程序自行决定的,协议栈并不能控制这一行为。

在这样的情况下, 如果一收到数据就马上发送出去,
就可能会发送大量的小包,导致网络效率下降,
因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送,不同种类和版本的操作系统会有所不同,不能一概而论,
但都是根据下面几个要素来判断的。

**第一个判断要素是每个网络包能容纳的数据长度,协议栈会根据一个 叫作 MTU 的参数来进行判断。**

（Maximum Transmission Unit,最大传输单元。）

MTU 表示一个网络包的最大长度,在以太 网中一般是 1500 字节(图 2.5)。

（在使用 PPPoE 的 ADSL 等网络中,需要额外增加一些头部数据,因此MTU 会小于 1500 字节。）

![图 2.5 MTU 与 MSS](images/2.5.png)

MTU 是包含头部的总长度,因此需要从 MTU 减去头部的长度,
然后得到的长度就是一个网络包中所能容纳的最大数据长度,这一长度叫作 MSS。

（MSS:Maximum Segment Size,最大分段大小。 
TCP 和 IP 的头部加起来一般是 40 字节,因此 MTU 减去这个长度就是 MSS。
例如,在以太网中,MTU 为 1500,因此 MSS 就是 1460。
TCP/IP 可以使用一些可选参数 (protocol option),如加密等,这时头部的长度会增加,
那么 MSS 就会随着头部长度增加而相应缩短。）

当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去,
就可以避免发送大量小包的问题了。

    MTU:一个网络包的最大长度,以太网中一般为 1500 字节。 
    MSS:除去头部之后,一个网络包所能容纳的 TCP 数据的最大长度。


**另一个判断要素是时间。**

当应用程序发送数据的频率不高的时候,如果每次都等到长度接近 MSS 时再发送,
可能会因为等待时间太长而造成发送延迟,这种情况下,
即便缓冲区中的数据长度没有达到 MSS,也应该果断发送出去。

为此,协议栈的内部有一个计时器,当经过一定时间之后, 就会把网络包发送出去。

判断要素就是这两个,但它们其实是互相矛盾的。

如果长度优先,那么网络的效率会提高,但可能会因为等待填满缓冲区而产生延迟;
相反地, 如果时间优先,那么延迟时间会变少,但又会降低网络的效率。

因此,在进行发送操作时需要综合考虑这两个要素以达到平衡。

不过,TCP 协议规格中并没有告诉我们怎样才能平衡,
因此实际如何判断是由协议栈的开发者来决定的,
也正是由于这个原因,不同种类和版本的操作系统在相关操作上也就存在差异。

正如前面所说,如果仅靠协议栈来判断发送的时机可能会带来一些问题,
因此协议栈也给应用程序保留了控制发送时机的余地。
应用程序在发送数据时可以指定一些选项,
比如如果指定“不等待填满缓冲区直接发送”,则协议栈就会按照要求直接发送数据。
像浏览器这种会话型的应用程序在向服务器发送数据时,等待填满缓冲区导致延迟会产生很大影响,
因此一般会使用直接发送的选项。

## 2.3.2 对较大的数据进行拆分

HTTP 请求消息一般不会很长,一个网络包就能装得下,
但如果其中要提交表单数据,长度就可能超过一个网络包所能容纳的数据量,
比如在博客或者论坛上发表一篇长文就属于这种情况。

这种情况下,发送缓冲区中的数据就会超过 MSS 的长度,
这时我们当然不需要继续等待后面的数据了。
发送缓冲区中的数据会被以 MSS 长度为单位进行拆分,
拆分出来的每块数据会被放进单独的网络包中。

根据发送缓冲区中的数据拆分的情况,
当判断需要发送这些数据时,就在每一块数据前面加上 TCP 头部,
并根据套接字中记录的控制信息标记发送方和接收方的端口号,
然后交给 IP 模块来执行发送数据的操作(图 2.6)。

![图 2.6 应用程序数据的拆分发送](images/2.6.png)

（IP 模块会在网络包前面添加 IP 头部和以太网的 MAC 头部后发送网络包, 
这些操作我们将稍后讲解。）

## ￼2.3.3 使用 ACK 号确认网络包已收到

到这里,网络包已经装好数据并发往服务器了,但数据发送操作还没有结束。
TCP 具备确认对方是否成功收到网络包,以及当对方没收到时进行重发的功能,
因此在发送网络包之后,接下来还需要进行确认操作。

我们先来看一下确认的原理(图 2.7)。

![图 2.7 序号和 ACK 号的用法](images/2.7.png)

**“序号”**

首先,TCP 模块在拆分数据时, 
会先算好每一块数据相当于从头开始的第几个字节,
接下来在发送这一块数据时,将算好的字节数写在 TCP 头部中,
“序号”字段就是派在这个用场上的。

**发送数据的长度**

然后,发送数据的长度也需要告知接收方,不过这个并不是放在 TCP 头部里面的,
因为用整个网络包的长度减去头部的长度就可以得到数据的长度,
所以接收方可以用这种方法来进行计算。

有了上面两个数值, 我们就可以知道发送的数据是从第几个字节开始,长度是多少了。

通过这些信息,接收方还能够检查收到的网络包有没有遗漏。

例如, 假设上次接收到第 1460 字节,那么接下来如果收到序号为 1461 的包,说明中间没有遗漏;
但如果收到的包序号为 2921,那就说明中间有包遗漏了。

**ACK 号**

像这样,如果确认没有遗漏,接收方会将到目前为止接收到的数据长度加起来,
计算出一共已经收到了多少个字节,然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方

（返回 ACK 号时,除了要设置 ACK 号的值以外,还需要将控制位中的 ACK 比特设为 1,
这代表 ACK 号字段有效,接收方也就可以知道这个网络包是用来告知 ACK 号的。）

**确认响应**

简单来说,发送方说的是“现在发送的 是从第 ×× 字节开始的部分,一共有 ×× 字节哦!”
而接收方则回复说,“到第 ×× 字节之前的数据我已经都收到了哦!”
这个返回 ACK 号的操作被称为确认响应,
通过这样的方式,发送方就能够确认对方到底收到了多少数据。

然而,图 2.7 的例子和实际情况还是有些出入的。
在实际的通信中, 序号并不是从 1 开始的,而是需要用随机数计算出一个初始值,
这是因为如果序号都从 1 开始,通信过程就会非常容易预测,有人会利用这一点来发动攻击。
但是如果初始值是随机的,那么对方就搞不清楚序号到底是从多少开始计算的,
因此需要在开始收发数据之前将初始值告知通信对象。

**SYN**

大家应该还记得在我们刚才讲过的连接过程中,
有一个将 SYN 控制位设为 1 并发送给服务器的操作,就是在这一步将序号的初始值告知对方的。
实际上,在将 SYN 设为 1 的同时,还需要同时设置序号字段的值,而这里的值就代表序号的初始值。

（我们在前面讲连接操作的时候说过 SYN 为 1 表示进行连接,
这是因为将 SYN 设为 1 并告知初始序号这一操作仅在连接过程中出现,
因此发送 SYN 为 1 的网络包就表示发起连接的意思。
实际上,SYN 是 Synchronize(同步)的缩写,意思是通过告知初始序号使通信双方保持步调一致,
以便完成后续的数据收发检查,这才是 SYN 原本的含义。）

前面介绍了通过序号和 ACK 号来进行数据确认的思路,但仅凭这些还不够,
因为我们刚刚只考虑了单向的数据传输,但 TCP 数据收发是双向的,
在客户端向服务器发送数据的同时,服务器也会向客户端发送数据, 因此必须要想办法应对这样的情况。

不过,这其实也不难,图 2.7 中展示的客户端向服务器发送数据的情形,
我们只要增加一种左右相反的情形就可以了,如图 2.8 所示。

![图 2.8 数据双向传输时的情况](images/2.8.png)

首先客户端先计算出一个序号,然后将序号和数据一起发送给服务器,
服务器收到之后会计算 ACK 号并返回给客户端;
相反地,服务器也需要先计算出另一个序号,然后将序号和数据一起发送给客户端,
客户端收到之后计算 ACK 号并返回给服务器。

此外,如图所示, 客户端和服务器双方都需要各自计算序号,
因此双方需要在连接过程中互相告知自己计算的序号初始值。

明白原理之后我们来看一下实际的工作过程(图 2.9)。

![图 2.9 序号和 ACK 号的交互](images/2.9.png)

首先,客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值,
并将这个值发送给服务器(图 2.9 ①)。

接下来,服务器会通过这个初始值计算出 ACK 号并返回给客户端(图 2.9 ②)。

初始值有可能在通信过程中丢失,因此当服务器收到初始值后需要返回 ACK 号作为确认。

同时,服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值,
并将这个值发送给客户端(图 2.9 ②)。

接下来像刚才一样,客户端也需要根据服务器发来的初始值计算出 ACK 号并返回给服务器(图 2.9 ③)。

到这里,序号和 ACK 号都已经准备完成了,接下来就可以进入数据收发阶段了。

数据收发操作本身是可以双向同时进行的,但 Web 中是先由客户端向服务器发送请求,
序号也会跟随数据一起发送(图 2.9 ④)。

然后,服务器收到数据后再返回 ACK 号(图 2.9 ⑤)。

从服务器向客户端发送数据的过程则正好相反(图 2.9 ⑥⑦)。

TCP 采用这样的方式确认对方是否收到了数据,
在得到对方确认之前,发送过的包都会保存在发送缓冲区中。
如果对方没有返回某些包对应的 ACK 号,那么就重新发送这些包。

这一机制非常强大。
通过这一机制,我们可以确认接收方有没有收到某个包,
如果没有收到则重新发送,这样一来,无论网络中发生任何错误, 
我们都可以发现并采取补救措施(重传网络包)。
反过来说,有了这一机制,我们就不需要在其他地方对错误进行补救了。

因此,网卡、集线器、路由器都没有错误补偿机制,一旦检测到错误就直接丢弃相应的包。

应用程序也是一样,因为采用 TCP 传输,即便发生一些错误对方最终也能够收到正确的数据,
所以应用程序只管自顾自地发送这些数据就好了。

不过,如果发生网络中断、服务器宕机等问题,那么无论 TCP 怎样重传都不管用。
这种情况下,无论如何尝试都是徒劳,因此 TCP 会在尝试几次重传无效之后强制结束通信,并向应用程序报错。

    通过“序号”和“ACK 号”可以确认接收方是否收到了网络包。

