# 2.3 收发数据

# 2.3.1 将 HTTP 请求消息交给协议栈

当控制流程从 connect 回到应用程序之后,接下来就进入数据收发阶段了。

数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的(图 2.3③),
协议栈收到数据后执行发送操作,这一操作包含如下要点。

首先,协议栈并不关心应用程序传来的数据是什么内容。
应用程序在调用 write 时会指定发送数据的长度,

在协议栈看来,要发送的数据就是一定长度的二进制字节序列而已。

其次,协议栈并不是一收到数据就马上发送出去,
而是会将数据存放在内部的发送缓冲区中,并等待应用程序的下一段数据。

这样做是有道理的。

应用程序交给协议栈发送的数据长度是由应用程序本身来决定的,
不同的应用程序在实现上有所不同,有些程序会一次性传递所有的数据,
有些程序则会逐字节或者逐行传递数据。

总之,一次将多少数据交给协议栈是由应用程序自行决定的,协议栈并不能控制这一行为。

在这样的情况下, 如果一收到数据就马上发送出去,
就可能会发送大量的小包,导致网络效率下降,
因此需要在数据积累到一定量时再发送出去。

至于要积累多少数据才能发送,不同种类和版本的操作系统会有所不同,不能一概而论,
但都是根据下面几个要素来判断的。

**第一个判断要素是每个网络包能容纳的数据长度,协议栈会根据一个 叫作 MTU 的参数来进行判断。**

（Maximum Transmission Unit,最大传输单元。）

MTU 表示一个网络包的最大长度,在以太 网中一般是 1500 字节(图 2.5)。

（在使用 PPPoE 的 ADSL 等网络中,需要额外增加一些头部数据,因此MTU 会小于 1500 字节。）

![图 2.5 MTU 与 MSS](images/2.5.png)

MTU 是包含头部的总长度,因此需要从 MTU 减去头部的长度,
然后得到的长度就是一个网络包中所能容纳的最大数据长度,这一长度叫作 MSS。

（MSS:Maximum Segment Size,最大分段大小。 
TCP 和 IP 的头部加起来一般是 40 字节,因此 MTU 减去这个长度就是 MSS。
例如,在以太网中,MTU 为 1500,因此 MSS 就是 1460。
TCP/IP 可以使用一些可选参数 (protocol option),如加密等,这时头部的长度会增加,
那么 MSS 就会随着头部长度增加而相应缩短。）

当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去,
就可以避免发送大量小包的问题了。

    MTU:一个网络包的最大长度,以太网中一般为 1500 字节。 
    MSS:除去头部之后,一个网络包所能容纳的 TCP 数据的最大长度。


**另一个判断要素是时间。**

当应用程序发送数据的频率不高的时候,如果每次都等到长度接近 MSS 时再发送,
可能会因为等待时间太长而造成发送延迟,这种情况下,
即便缓冲区中的数据长度没有达到 MSS,也应该果断发送出去。

为此,协议栈的内部有一个计时器,当经过一定时间之后, 就会把网络包发送出去。

判断要素就是这两个,但它们其实是互相矛盾的。

如果长度优先,那么网络的效率会提高,但可能会因为等待填满缓冲区而产生延迟;
相反地, 如果时间优先,那么延迟时间会变少,但又会降低网络的效率。

因此,在进行发送操作时需要综合考虑这两个要素以达到平衡。

不过,TCP 协议规格中并没有告诉我们怎样才能平衡,
因此实际如何判断是由协议栈的开发者来决定的,
也正是由于这个原因,不同种类和版本的操作系统在相关操作上也就存在差异。

正如前面所说,如果仅靠协议栈来判断发送的时机可能会带来一些问题,
因此协议栈也给应用程序保留了控制发送时机的余地。
应用程序在发送数据时可以指定一些选项,
比如如果指定“不等待填满缓冲区直接发送”,则协议栈就会按照要求直接发送数据。
像浏览器这种会话型的应用程序在向服务器发送数据时,等待填满缓冲区导致延迟会产生很大影响,
因此一般会使用直接发送的选项。