 # 异步编程

**异步 API**：

* 浏览器端
    * 事件
    * 定时器：`setTimeout()` `setInterval()`
    * ajax

* node 端
    * fs 模块：`readFile()` `writeFile()` `readdir()`

## 1. 回调函数

回调函数（callback）：获取异步操作的结果。

一般情况下，把函数作为参数的目的就是为了获取函数内部的异步操作结果。

```javascript
function fn(callback) {
  setTimeout(() => {
    let data = 'hello';
    callback(data);
  });
}

fn((data) => {
  console.log(data);
});
```

## 2. Promise

### 2.1. 引入

#### 2.1.1. 回调地狱（callback hell）

![./images/callback_hell.jpg](./images/callback_hell.jpg)

#### 2.1.2. 无法保证顺序的多个异步操作

目录

```
data/
  1.txt（内容为：aaa）
  2.txt（内容为：bbb）
  3.txt（内容为：ccc）
```

代码

```javascript
const fs = require('fs');

fs.readFile('data/1.txt', (err, data) => {
  if (err) { throw err; }
  console.log(data.toString());
});

fs.readFile('data/2.txt', (err, data) => {
  if (err) { throw err; }
  console.log(data.toString());
});

fs.readFile('data/3.txt', (err, data) => {
  if (err) { throw err; }
  console.log(data.toString());
});
```

#### 2.1.3. 通过嵌套的方式来保证多个异步操作的顺序

```javascript
const fs = require('fs');

fs.readFile('data/1.txt', (err, data) => {
  if (err) { throw err; }
  console.log(data.toString());
  fs.readFile('data/2.txt', (err2, data2) => {
    if (err2) { throw err2; }
    console.log(data2.toString());
    fs.readFile('data/3.txt', (err3, data3) => {
      if (err3) { throw err3; }
      console.log(data3.toString());
    });
  });
});
```